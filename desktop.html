<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rose Particles</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #1d1f23;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="map"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let scene, camera, renderer, particles, velocities = [];
    const mouse = new THREE.Vector2(-1000, -1000); // start far away

    const redPoints = [
      [-40, -50], [-38, -50], [-36, -50], [-34, -50], [-32, -50], [-30, -48], [-28, -48],
      [-26, -48], [-24, -46], [-22, -46], [-20, -44], [-18, -44], [-16, -42], [-14, -40],
      [-12, -38], [-10, -36], [-8, -34], [-6, -32], [-4, -30], [-2, -28], [0, -26],
      [2, -24], [4, -22], [6, -20], [8, -18], [10, -16], [12, -14], [14, -12], [16, -10],
      [18, -8], [20, -6], [22, -4], [24, -2], [26, 0], [28, 2], [30, 4], [32, 6],
      [34, 8], [36, 10], [38, 12], [40, 14]
    ];

    const greenPoints = [
      [0, 20], [0, 22], [0, 24], [0, 26], [0, 28], [0, 30], [0, 32], [0, 34],
      [0, 36], [0, 38], [0, 40], [0, 42], [0, 44], [0, 46], [0, 48], [0, 50]
    ];

    const points = redPoints.map(p => [...p, 0, 'red'])
      .concat(greenPoints.map(p => [...p, 0, 'green']));

    function init() {
      const canvas = document.getElementById('map');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 300;

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];

      points.forEach(([x, y, z, color]) => {
        positions.push(x, y, z);
        const c = new THREE.Color(color);
        colors.push(c.r, c.g, c.b);
        velocities.push(new THREE.Vector3());
      });

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      // Load the image texture
      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load('rose.png'); // Replace with your image URL

      // Use the texture in the PointsMaterial
      const material = new THREE.PointsMaterial({
        size: 10, // Adjust size of the particles
        map: texture,
        transparent: true,
        blending: THREE.AdditiveBlending
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('resize', onResize);

      animate();
    }

    function onMouseMove(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    }

    function animate() {
      requestAnimationFrame(animate);

      const positions = particles.geometry.attributes.position;

      for (let i = 0; i < points.length; i++) {
        const i3 = i * 3;
        const orig = new THREE.Vector3(points[i][0], points[i][1], points[i][2]);
        const pos = new THREE.Vector3(
          positions.array[i3],
          positions.array[i3 + 1],
          positions.array[i3 + 2]
        );

        const mouse3D = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
        const dir = pos.clone().sub(mouse3D);
        const dist = dir.length();

        if (dist < 50) {
          dir.normalize().multiplyScalar((50 - dist) * 0.15);
          velocities[i].add(dir);
        }

        const spring = orig.clone().sub(pos).multiplyScalar(0.05);
        velocities[i].add(spring);
        velocities[i].multiplyScalar(0.9);

        pos.add(velocities[i]);

        positions.array[i3] = pos.x;
        positions.array[i3 + 1] = pos.y;
        positions.array[i3 + 2] = pos.z;
      }

      positions.needsUpdate = true;
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
