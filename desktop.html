<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rose Particles</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #1d1f23;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="map"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let scene, camera, renderer, particles, positions, velocities = [];
    const mouse = new THREE.Vector2(-10, -10); // Hide by default

    // ✅ FIXED RED & GREEN PARTICLE COORDINATES — no trailing commas or syntax issues
    const redPoints = [
      [-26.00, -102.00], [-24.00, -102.00], [-22.00, -102.00], [-20.00, -102.00], [-18.00, -102.00],
      [-16.00, -102.00], [-14.00, -102.00], [-12.00, -102.00], [-34.00, -100.00], [-32.00, -100.00],
      [-30.00, -100.00], [-28.00, -100.00], [-26.00, -100.00], [-24.00, -100.00], [-22.00, -100.00],
      [-20.00, -100.00], [-18.00, -100.00], [-16.00, -100.00], [-14.00, -100.00], [-12.00, -100.00],
      [-10.00, -100.00], [-8.00, -100.00], [-6.00, -100.00]
    ];

    const greenPoints = [
      [-2.00, 58.00], [0.00, 58.00], [2.00, 58.00], [-4.00, 60.00], [-2.00, 60.00],
      [0.00, 60.00], [2.00, 60.00], [4.00, 60.00], [-6.00, 62.00], [-4.00, 62.00]
    ];

    const combinedPoints = redPoints.map(p => [...p, 0.6, 'red'])
      .concat(greenPoints.map(p => [...p, 0.6, 'green']));

    function init() {
      const canvas = document.getElementById('map');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 500;

      const geometry = new THREE.BufferGeometry();
      const posArray = [];
      const colorArray = [];

      combinedPoints.forEach(([x, y, z, alpha, color]) => {
        posArray.push(x, y, z);
        velocities.push(new THREE.Vector3());
        const c = new THREE.Color(color);
        colorArray.push(c.r, c.g, c.b);
      });

      positions = new Float32Array(posArray);
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));

      const material = new THREE.PointsMaterial({
        size: 2.5,
        vertexColors: true,
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('resize', onResize);

      animate();
    }

    function onMouseMove(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    }

    function animate() {
      requestAnimationFrame(animate);

      const positionsAttr = particles.geometry.attributes.position;

      for (let i = 0; i < combinedPoints.length; i++) {
        const i3 = i * 3;
        const orig = new THREE.Vector3(...combinedPoints[i]);
        const pos = new THREE.Vector3(
          positionsAttr.array[i3],
          positionsAttr.array[i3 + 1],
          positionsAttr.array[i3 + 2]
        );

        const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
        const dir = pos.clone().sub(vec);
        const dist = dir.length();

        if (dist < 80) {
          dir.normalize().multiplyScalar((80 - dist) * 0.15);
          velocities[i].add(dir);
        }

        const spring = orig.clone().sub(pos).multiplyScalar(0.02);
        velocities[i].add(spring);
        velocities[i].multiplyScalar(0.9);

        pos.add(velocities[i]);

        positionsAttr.array[i3] = pos.x;
        positionsAttr.array[i3 + 1] = pos.y;
        positionsAttr.array[i3 + 2] = pos.z;
      }

      positionsAttr.needsUpdate = true;
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
