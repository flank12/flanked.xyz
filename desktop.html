<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Effect - Rose Image</title>
    <style>
        body, html, canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1d1f23;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="map"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.0/gsap.min.js"></script>
    <script>
        var renderer, scene, camera, ww, wh, particles;
        var texture, imagedata;
        var previousTime = 0;
        var centerVector = new THREE.Vector3(0, 0, 0);

        ww = window.innerWidth;
        wh = window.innerHeight;

        // Get pixel data from image
        var getImageData = function(image) {
            var canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0);
            return ctx.getImageData(0, 0, image.width, image.height);
        };

        // Draw the particles based on the image data (rose image)
        var drawTheMap = function() {
            var geometry = new THREE.Geometry();
            var material = new THREE.PointsMaterial({
                size: 3,
                color: 0x313742,
                sizeAttenuation: false
            });

            // Generate particles based on pixel data
            for (var y = 0; y < imagedata.height; y += 2) {
                for (var x = 0; x < imagedata.width; x += 2) {
                    if (imagedata.data[(x * 4 + y * 4 * imagedata.width) + 3] > 128) {
                        var vertex = new THREE.Vector3();
                        vertex.x = Math.random() * 1000 - 500;
                        vertex.y = Math.random() * 1000 - 500;
                        vertex.z = -Math.random() * 500;

                        vertex.destination = {
                            x: x - imagedata.width / 2,
                            y: -y + imagedata.height / 2,
                            z: 0
                        };

                        vertex.speed = Math.random() / 200 + 0.015;

                        geometry.vertices.push(vertex);
                    }
                }
            }

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            requestAnimationFrame(render);
        };

        // Set up the scene and camera
        var init = function() {
            THREE.ImageUtils.crossOrigin = '';
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById("map"),
                antialias: true
            });
            renderer.setSize(ww, wh);
            renderer.setClearColor(0x1d1f23);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(50, ww / wh, 0.1, 10000);
            camera.position.set(-100, 0, 220);
            camera.lookAt(centerVector);
            scene.add(camera);

            // Load the rose image
            texture = new THREE.TextureLoader().load("rose.png", function(texture) {
                imagedata = getImageData(texture.image);
                drawTheMap();
            });

            window.addEventListener('resize', onResize, false);
            window.addEventListener('mousemove', onMouseMove, false); // Listen for mouse movement
        };

        // Resize the canvas on window resize
        var onResize = function() {
            ww = window.innerWidth;
            wh = window.innerHeight;
            renderer.setSize(ww, wh);
            camera.aspect = ww / wh;
            camera.updateProjectionMatrix();
        };

        // Track mouse position for hover effect
        var mouse = new THREE.Vector2();

        var onMouseMove = function(event) {
            mouse.x = (event.clientX / ww) * 2 - 1;
            mouse.y = -(event.clientY / wh) * 2 + 1;
        };

        // Render the particles and animate them
        var render = function(a) {
            requestAnimationFrame(render);

            // Update particle positions and handle hover effect
            particles.geometry.vertices.forEach((particle) => {
                particle.x += (particle.destination.x - particle.x) * particle.speed;
                particle.y += (particle.destination.y - particle.y) * particle.speed;
                particle.z += (particle.destination.z - particle.z) * particle.speed;
            });

            // Hover effect: Make particles form a ball when the mouse is close to the center
            if (Math.abs(mouse.x) < 0.1 && Math.abs(mouse.y) < 0.1) {
                particles.geometry.vertices.forEach((particle) => {
                    // Make particles move toward a spherical form at the center
                    var dist = Math.sqrt(particle.x * particle.x + particle.y * particle.y + particle.z * particle.z);
                    var targetRadius = 100;
                    var scale = targetRadius / dist;

                    gsap.to(particle, {
                        duration: 1,
                        x: particle.x * scale,
                        y: particle.y * scale,
                        z: particle.z * scale,
                        ease: "power2.inOut"
                    });
                });
            }

            particles.geometry.verticesNeedUpdate = true;

            // Animate camera rotation
            camera.position.x = Math.sin(a / 5000) * 100;
            camera.position.y = Math.cos(a / 5000) * 100;
            camera.lookAt(centerVector);

            renderer.render(scene, camera);
        };

        // Initialize the scene and start the rendering loop
        init();
    </script>
</body>
</html>
