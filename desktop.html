<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rose Particles</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #1d1f23;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="map"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let scene, camera, renderer, particles, velocities = [];
    const mouse = new THREE.Vector2(-1000, -1000); // start far away
    const imageWidth = 100; // Image width in pixels
    const imageHeight = 100; // Image height in pixels

    // Load the image texture
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load('rose.png'); // Replace with your image URL
    texture.magFilter = THREE.NearestFilter; // To avoid texture smoothing
    texture.minFilter = THREE.NearestFilter;

    const points = [];

    // Create a 2D grid of particles corresponding to the image's pixels
    function createParticleGrid() {
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          const i = (y * imageWidth + x);
          points.push([x - imageWidth / 2, y - imageHeight / 2, 0, i]);
        }
      }
    }

    function init() {
      const canvas = document.getElementById('map');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 300;

      createParticleGrid(); // Create the particle grid based on the image

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const uvs = [];

      points.forEach(([x, y, z, index]) => {
        positions.push(x, y, z);
        // Map each particle to a corresponding UV coordinate on the texture
        const u = (index % imageWidth) / imageWidth;
        const v = Math.floor(index / imageWidth) / imageHeight;
        uvs.push(u, v);
      });

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

      const material = new THREE.PointsMaterial({
        size: 5, // Adjust size of the particles
        map: texture,
        transparent: true,
        blending: THREE.AdditiveBlending,
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('resize', onResize);

      animate();
    }

    function onMouseMove(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    }

    function animate() {
      requestAnimationFrame(animate);

      const positions = particles.geometry.attributes.position;

      for (let i = 0; i < points.length; i++) {
        const i3 = i * 3;
        const orig = new THREE.Vector3(points[i][0], points[i][1], points[i][2]);
        const pos = new THREE.Vector3(
          positions.array[i3],
          positions.array[i3 + 1],
          positions.array[i3 + 2]
        );

        const mouse3D = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
        const dir = pos.clone().sub(mouse3D);
        const dist = dir.length();

        if (dist < 50) {
          dir.normalize().multiplyScalar((50 - dist) * 0.15);
          velocities[i].add(dir);
        }

        const spring = orig.clone().sub(pos).multiplyScalar(0.05);
        velocities[i].add(spring);
        velocities[i].multiplyScalar(0.9);

        pos.add(velocities[i]);

        positions.array[i3] = pos.x;
        positions.array[i3 + 1] = pos.y;
        positions.array[i3 + 2] = pos.z;
      }

      positions.needsUpdate = true;
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
